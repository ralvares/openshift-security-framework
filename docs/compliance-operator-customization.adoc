

= Compliance Beyond Built-in Profiles: Automating Unique Compliance Checks with OpenShift using CustomRule

== Introduction

For security teams responsible for Red Hat OpenShift, the Compliance Operator provides automated baseline checks for common standards (CIS, PCI-DSS, etc.) and produces evidence auditors expect. But auditors and internal policy owners often ask for controls that live outside those standard profiles, organization-specific requirements such as mandatory resource labeling, restricting which users can access cardholder-data-processing applications, or enforcing use of a single, central database.

Historically, these requests result in manual, brittle checks: ad-hoc scripts, grepping `oc` outputs, or marking items as "manually verified." The CustomRule Custom Resource (CRD) addresses this gap by letting you codify custom checks using the Common Expression Language (CEL) and run them with the Compliance Operator alongside built-in checks.

This article shows how to turn auditor requests into executable CustomRule manifests, add them to a TailoredProfile, and include them in Compliance Operator scans so they produce repeatable, auditable evidence.

[important]
.Note on Feature Status
The CustomRule feature is Tech Preview. It is available for testing and evaluation only and is not supported by Red Hat Technical Support. The API and behavior may change before General Availability (GA). Avoid using Tech Preview features in production clusters.

== Understanding the CustomRule CRD

CustomRule behaves similarly to the existing Rule CRD but uses CEL expressions as the evaluation engine. Key fields in a CustomRule manifest include:

- `expression`: the CEL expression that evaluates to `true` for compliant resources.
- `inputs`: the Kubernetes API resources the expression evaluates (keeps scans efficient).
- `scannerType`: must be `CEL` for CEL-based rules.
- `title`, `description`, `severity`, and `failureReason`: metadata and actionable guidance when a check fails.

CEL is a small, expressive language well-suited to policy evaluation; you may have seen it in Kubernetes admission policy contexts.

== Examples

=== Example 1: Audit cluster-admin Access with an Allow-List (aligns to CIS 5.1.1)

This CustomRule enforces an allow-list of principals permitted to hold the `cluster-admin` binding. The rule passes only if every subject bound to the `cluster-admin` ClusterRole is present in an approved list.

[source,yaml]
----
apiVersion: compliance.openshift.io/v1alpha1
kind: CustomRule
metadata:
    name: cluster-admin-allow-list
    namespace: openshift-compliance
spec:
    title: Audit cluster-admin access against an allow-list
    description: |-
        Audits subjects bound to the 'cluster-admin' role against a
        pre-defined allow-list. Aligns with CIS 5.1.1.
    failureReason: |-
        Found subject(s) bound to 'cluster-admin' that are NOT on the allow-list.
    severity: high
    id: cluster_admin_allow_list
    checkType: Platform
    scannerType: CEL
    inputs:
        - name: crbs
          kubernetesInputSpec:
            apiVersion: rbac.authorization.k8s.io/v1
            resource: clusterrolebindings
    expression: |-
        crbs.items.filter(crb, crb.metadata.name == 'cluster-admin')[0]
            .subjects.all(subject,
                (subject.kind == 'User' && subject.name in [
                    'kubeadmin',
                    'system:admin',
                    'alice@my-company.com'
                ]) ||
                (subject.kind == 'Group' && subject.name in [
                    'system:masters',
                    'ocp-sre-team'
                ]) ||
                (subject.kind == 'ServiceAccount' &&
                    has(subject.namespace) &&
                    (subject.namespace + '/' + subject.name) in [
                        'openshift-monitoring/prometheus-k8s'
                    ]
                )
            )
----

=== Example 2: Discover Unapproved (Shadow) Databases

This rule checks for pods running common database images outside approved namespaces (for example, `central-dba-prod`). If a pod runs a database image in a non-approved namespace, the rule fails and the `failureReason` explains investigation and remediation steps.

[source,yaml]
----
apiVersion: compliance.openshift.io/v1alpha1
kind: CustomRule
metadata:
    name: disallow-shadow-databases
    namespace: openshift-compliance
spec:
    title: Disallow Unapproved Database Pods in App Namespaces
    description: |-
        Ensures application teams do not deploy 'shadow' database instances.
    failureReason: |-
        One or more pods are running disallowed DB images in unapproved namespaces.
    severity: high
    id: disallow_shadow_databases
    checkType: Platform
    scannerType: CEL
    inputs:
        - name: pods
          kubernetesInputSpec:
            apiVersion: v1
            resource: pods
    expression: |
        pods.items.all(pod,
            pod.metadata.namespace in [
                'central-dba-prod',
                'openshift-monitoring'
            ] ||
            pod.spec.containers.all(container,
                !['postgres','mysql','mariadb','mongo','redis']
                    .exists(db, container.image.contains(db))
            )
        )
----

=== Example 3: Verify Allowed Registries Configured

Ensure the cluster's image configuration includes required trusted registries.

[source,yaml]
----
apiVersion: compliance.openshift.io/v1alpha1
kind: CustomRule
metadata:
    name: allowed-registries-configured
    namespace: openshift-compliance
spec:
    title: Allowed registries are configured
    description: |-
        Ensures trusted registries are defined in the cluster image config.
    failureReason: |-
        Required trusted registry missing from allowedRegistries.
    severity: medium
    id: allowed_registries_configured
    checkType: Platform
    scannerType: CEL
    inputs:
        - name: imageConfigs
          kubernetesInputSpec:
            apiVersion: config.openshift.io/v1
            resource: images
    expression: |
        imageConfigs.items.exists(
            img, img.metadata.name == 'cluster' &&
            has(img.spec.registrySources) &&
            img.spec.registrySources != null &&
            has(img.spec.registrySources.allowedRegistries) &&
            img.spec.registrySources.allowedRegistries != null &&
            type(img.spec.registrySources.allowedRegistries) == list &&
            'my-trusted-registry.internal.example.com'
                in img.spec.registrySources.allowedRegistries
        )
----

These examples can be combined: enforce that only trusted registries are used while preventing unapproved database images in application namespaces.

== Integrating CustomRule Resources into a Scan

Three steps:

.Step 1: Create the CustomRule
Apply each `CustomRule` manifest to the `openshift-compliance` namespace:

```
oc apply -f <your-customrule>.yaml -n openshift-compliance
```

.Step 2: Add the rules to a `TailoredProfile`
CustomRule resources are included by adding them to a `TailoredProfile`. Note: a single `TailoredProfile` cannot mix standard `Rule` resources and `CustomRule` resources; keep them separate.

[source,yaml]
----
apiVersion: compliance.openshift.io/v1alpha1
kind: TailoredProfile
metadata:
    name: custom-security-checks
    namespace: openshift-compliance
spec:
    title: Custom Security Profile
    description: Custom security compliance profile using CEL-based CustomRules
    enableRules:
        - name: cluster-admin-allow-list
          kind: CustomRule
          rationale: CIS 5.1.1 â€” audit cluster-admin bindings
        - name: disallow-shadow-databases
          kind: CustomRule
          rationale: Prevent unapproved database workloads
        - name: allowed-registries-configured
          kind: CustomRule
          rationale: Restrict image pulls to trusted registries
----

.Step 3: Execute the scan with a `ScanSettingBinding`
Create a `ScanSettingBinding` to link the `TailoredProfile` to scan settings (for example, the `default` ScanSetting).

[source,yaml]
----
apiVersion: compliance.openshift.io/v1alpha1
kind: ScanSettingBinding
metadata:
    name: custom-security-scan
    namespace: openshift-compliance
profiles:
    - name: custom-security-checks
      kind: TailoredProfile
      apiGroup: compliance.openshift.io/v1alpha1
settingsRef:
    name: default
    kind: ScanSetting
    apiGroup: compliance.openshift.io/v1alpha1
----

== Reviewing Scan Results

After the `ScanSettingBinding` is applied the Compliance Operator will run the scan. To view results:

```
oc get compliancecheckresults
```

Example output:

[source]
----
NAME                                                      STATUS   SEVERITY
custom-security-scan-cluster-admin-allow-list             FAIL     high
custom-security-scan-disallow-shadow-databases            FAIL     high
custom-security-scan-allowed-registries-configured        FAIL     high
----

A `FAIL` indicates the rule executed and identified non-compliant resources.

== NetworkPolicy Rules: detect allow-all and require deny-all in scoped namespaces

=== Production-ready TailoredProfile and ScanSettingBinding for NetworkPolicy CustomRules

Below are CRD-valid, production-ready YAMLs for running only the two NetworkPolicy CustomRules. These are ready to copy, apply, and use in your cluster.

[source,yaml]
----
apiVersion: compliance.openshift.io/v1alpha1
kind: TailoredProfile
metadata:
    name: networkpolicy-security-checks
    namespace: openshift-compliance
spec:
    title: NetworkPolicy Security Checks
    description: Custom checks enforcing NetworkPolicy standards for labeled namespaces
    enableRules:
        - name: netpol-disallow-allow-all-in-labeled-namespaces
          kind: CustomRule
          rationale: Detect allow-all NetworkPolicies in enforced namespaces
        - name: netpol-require-deny-all-in-labeled-namespaces
          kind: CustomRule
          rationale: Ensure deny-all NetworkPolicies exist in enforced namespaces
----

[source,yaml]
----
apiVersion: compliance.openshift.io/v1alpha1
kind: ScanSettingBinding
metadata:
    name: networkpolicy-security-scan
    namespace: openshift-compliance
profiles:
    - name: networkpolicy-security-checks
      kind: TailoredProfile
      apiGroup: compliance.openshift.io/v1alpha1
settingsRef:
    name: default
    kind: ScanSetting
    apiGroup: compliance.openshift.io/v1alpha1
----

Below are two `CustomRule` examples that scope enforcement to namespaces with the label `compliance/enforce-networkpolicies=true`. Modify the label key/value to match your organization.

=== Detect allow-all NetworkPolicies in labeled namespaces

This rule passes only when no "allow-all" NetworkPolicies exist in namespaces labeled `compliance/enforce-networkpolicies=true`.

[source,yaml]
----
apiVersion: compliance.openshift.io/v1alpha1
kind: CustomRule
metadata:
  name: netpol-disallow-allow-all-in-labeled-namespaces
  namespace: openshift-compliance
spec:
  title: Disallow allow-all NetworkPolicies in labeled namespaces
  description: |-
    Detects allow-all NetworkPolicies in namespaces labeled
    compliance/enforce-networkpolicies=true.
  failureReason: Allow-all NetworkPolicies found in enforced namespaces.
  severity: high
  id: netpol_disallow_allow_all_labeled
  checkType: Platform
  scannerType: CEL
  inputs:
    - name: netpols
      kubernetesInputSpec:
        apiVersion: networking.k8s.io/v1
        resource: networkpolicies
    - name: namespaces
      kubernetesInputSpec:
        apiVersion: v1
        resource: namespaces
  expression: |
    !netpols.items.exists(np,
      namespaces.items.exists(ns,
        ns.metadata.name == np.metadata.namespace &&
        has(ns.metadata.labels) &&
        ns.metadata.labels.exists(k, k == 'compliance/enforce-networkpolicies') &&
        ns.metadata.labels['compliance/enforce-networkpolicies'] == 'true'
      ) &&
      np.spec.podSelector == {} &&
      (
        (has(np.spec.ingress) && size(np.spec.ingress) == 1 && np.spec.ingress[0] == {}) ||
        (has(np.spec.egress)  && size(np.spec.egress) == 1 && np.spec.egress[0]  == {})
      )
    )
----

Notes:

- The expression returns `true` (pass) only if there are no matching allow-all NetworkPolicies in labeled namespaces.
- Adjust the label key/value to match your environment.

=== Require a deny-all NetworkPolicy in labeled namespaces
[source,yaml]
----
apiVersion: compliance.openshift.io/v1alpha1
kind: CustomRule
metadata:
  name: netpol-require-deny-all-in-labeled-namespaces
  namespace: openshift-compliance
spec:
  title: Require deny-all NetworkPolicy in labeled namespaces
  description: |-
    Ensures namespaces with compliance/enforce-networkpolicies=true
    have a deny-all NetworkPolicy.
  failureReason: |-
    One or more enforced namespaces lack a deny-all NetworkPolicy.
  severity: high
  id: netpol_require_deny_all_labeled
  checkType: Platform
  scannerType: CEL
  inputs:
    - name: netpols
      kubernetesInputSpec:
        apiVersion: networking.k8s.io/v1
        resource: networkpolicies
    - name: namespaces
      kubernetesInputSpec:
        apiVersion: v1
        resource: namespaces
  expression: |
    namespaces.items.all(ns,
      !(
        has(ns.metadata.labels) &&
        ns.metadata.labels.exists(k, k == 'compliance/enforce-networkpolicies') &&
        ns.metadata.labels['compliance/enforce-networkpolicies'] == 'true'
      ) ||
      netpols.items.exists(np,
        np.metadata.namespace == ns.metadata.name &&
        np.spec.podSelector == {} &&
        (!has(np.spec.ingress) || size(np.spec.ingress) == 0) &&
        (!has(np.spec.egress)  || size(np.spec.egress)  == 0)
      )
    )
----

== Best Practices for Authoring CustomRules

- **Passing logic:** CEL expressions should evaluate to `true` when compliant.
- **Descriptive names:** Use specific `metadata.name` values (e.g., `disallow-hostpath-volumes`).
- **Helpful descriptions:** Use `spec.description` to explain the risk and include commands to find violating resources.
- **Actionable `failureReason`:** Describe exact remediation steps administrators should take.
- **Resource efficiency:** In `spec.inputs`, request only the resources required by the expression.
- **Keep IDs consistent:** Make `spec.id` and `metadata.name` similar to reduce ambiguity.

== Basic Troubleshooting

- **CustomRule status:** `oc get customrule <your-rule> -o yaml`, an invalid CEL expression will put the rule into an Error state; the rule must be `Ready` to be added to a `TailoredProfile`.
- **TailoredProfile status:** Ensure the `TailoredProfile` is `Ready` before referencing it in a `ScanSettingBinding`.
- **Do not mix types:** A `TailoredProfile` cannot include both `Rule` and `CustomRule` kinds.
- **Rescanning:** After modifying a CustomRule, re-run scans by annotating `ComplianceScan` resources to re-generate `ComplianceCheckResult` objects.

== Scope & Limitations

CustomRule currently supports platform-level checks against Kubernetes and OpenShift API resources (Pods, Roles, cluster configuration, etc.). It does not support host-level checks (files, host processes, permissions). For host-level checks continue using existing node `Rule` resources shipped with the Compliance Operator. Host-level scanning may be considered in future releases.


== References

- CustomRule example repository: https://github.com/ComplianceAsCode/compliance-operator/tree/master/config/samples/custom-rules

