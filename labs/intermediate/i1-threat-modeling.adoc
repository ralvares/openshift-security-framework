= Lab: See the Attack Surface – Threat Modeling & Control Mapping
:role: Intermediate Architecture & Security Design
:skills: Threat Modeling, STRIDE, Control Mapping, Risk Prioritization
:mitre: STRIDE (Conceptual), T1195 (Supply Chain), T1021 (Lateral Movement), T1552 (Credentials), T1611 (Escape to Host)
:compliance: NIST 800-53 RA-3/RA-5, ISO 27001 A.8/A.15, SOC 2 CC3/CC7
:labid: LAB-I1

== Skill
You will turn a fuzzy “we should be secure” notion into a concise, living threat model and translate it directly into an ordered mitigation backlog that maps to concrete OpenShift / Red Hat controls.

== Objective
* Define scope, assets, data sensitivity, and trust boundaries
* Sketch a lightweight data flow (text first; diagram optional)
* Sample threats using STRIDE (balanced coverage) on key flows
* Map each higher‑value threat to one or more platform controls
* Prioritize into a small, defensible backlog (top 5–7 items)

== Why it Matters
Designing security without a threat model is like installing locks, cameras, and safes randomly in a new office tower—expensive and still full of blind spots. A compact model acts as the floor plan: you know where valuables sit, which doors are public, and which hallways connect sensitive rooms. Business outcome: money and time focus on the riskiest failure paths first; audit narratives become “why” stories, not scattered spreadsheets; incident responders already know likely pivot routes. Most high‑impact improvements are ordinary: remove a wildcard Role, add default‑deny NetworkPolicy, enforce image signatures. Ordinary, but chosen with intent.

== What it Solves
Without modeling, teams drift into:
* Reactive, ticket‑whack hardening (“fix whatever the scanner yells at today”)
* Lateral movement oversight (frontend quietly reaches database pods)
* Everything labeled “critical,” so nothing truly is
* Re‑litigated design debates (no shared artifact of prior reasoning)

With a model:
* Shared vocabulary: assets, boundaries, flows, threats
* Traceability: every control defends an identified path
* Faster audits: reviewers see risk rationale, not guesswork
* Focused backlog: sequence of high leverage, low regret steps

== Understanding the Attack Surface
[options="header"]
|===
| Asset / Flow | Primary Risk | Example Threat | Control Category
| Registry Supply Chain | Tampered image | Injected backdoor layer | Scanning + Signing
| Frontend ↔ API | Lateral movement | Compromised pod probes east-west | NetworkPolicy tiers
| API ↔ DB | Data exposure | Stolen DB creds reused | Secrets mgmt + RBAC
| CI → Cluster | Privilege misuse | Unsigned image deploy | Admission + RHACS
| Service Account Tokens | Replay | Token exfil reused elsewhere | Short-lived / Bound tokens
| Runtime Syscalls | Escape attempt | Dangerous syscall executes | Seccomp / SPO
| Privileged Actions | Escalation | Wildcard RBAC verbs | Custom RBAC roles
|===

== How to Secure (Lifecycle View)
* Build: Scan & sign images; fail CI on critical vulns or unsigned artifacts.
* Registry: Enforce digest use & store SBOMs for provenance.
* Deploy: Default‑deny NetworkPolicies + minimal Roles (no wildcards).
* Runtime: RHACS anomaly & policy checks; minimal seccomp; periodic compliance scans.

== How to Try It
. (Optional) Create visual aid namespaces:
[source,sh]
----
oc new-project app-frontend
oc new-project app-backend
oc new-project app-db
----
. List assets: code, images, secrets, database, CI system, cluster API.
. Textual data flow (sample below) – adjust to reality.
. Mark trust boundaries (Internet ingress, CI → cluster, app → db, registry ↔ kubelet).
. Apply STRIDE sampling to 5–10 flows (avoid exhaustiveness trap).
. Build a Threat → Control table (start with provided excerpt; extend locally).
. Qualitatively score (High/Med/Low impact & likelihood) + effort (S/M/L); sort.
. Turn top ranked 5–7 into backlog tickets with acceptance criteria.
. Commit artifact (`threat-model-app.md`) and schedule a quarterly review.
. (Optional) Cleanup:
[source,sh]
----
oc delete project app-frontend app-backend app-db --wait=false
----

== Data Flow (Text Form)
1. User → Route (TLS) → frontend
2. Frontend → API (ClusterIP)
3. API → DB (StatefulSet) – credentials via external secret
4. CI pipeline → push signed image → internal registry → nodes pull digest
5. Operators / SRE → oc CLI → API server
6. Audit + runtime events → logging / SIEM → dashboards & alerts

Trust Boundaries:
* External Internet
* Ingress controller
* Application tier separation
* CI environment
* Runtime (node/OS) boundary

== STRIDE Sampling (Examples)
[options="header"]
|===
| STRIDE | Example Scenario | Potential Control
| Spoofing | Stolen service account token reused | Short-lived tokens / RBAC scope
| Tampering | Unsigned image pushed & deployed | Signing + admission gate
| Repudiation | RBAC change without trace | GitOps-managed RBAC + audit logs
| Information Disclosure | Broad secret mounts | External secrets + narrow Roles
| Denial of Service | Unlimited pod CPU | Quotas + limits + autoscale guards
| Elevation of Privilege | Pod adds CAP_SYS_ADMIN | Hardened SCC + seccomp
|===

== Threat → Control Mapping (Excerpt)
[options="header"]
|===
| Threat | Control | Referenced Lab
| Root container escape try | Hardened SCC + seccomp | I3 / I9b
| East-west reconnaissance | Tiered NetworkPolicies | I4b
| Arbitrary external egress | EgressIP + baseline deny | I4a
| Token replay | Bound/rotated tokens | I2
| Unsigned image deploy | Scan + sign + admission | I5 / I10
| Secret dump via env | External secret projection | I6a / I6b
| Malicious syscall usage | SPO enforced profile | I9b
| Privilege escalation via RBAC | Custom Role scoping | I2
| Missing NetworkPolicy | Admission requirement | I10
| Compliance drift | Tailored profile scans | I8
| Suspicious exec | Audit + anomaly correlation | I7
|===

== Prioritizing Mitigations
Formula (simple): Rank = (Impact × Likelihood) / Effort. You want early wins: high rank, low change risk. Typical first five:
1. Default‑deny NetworkPolicy baseline
2. Image signature + digest enforcement
3. Remove wildcard Roles in prod namespaces
4. Externalize sensitive DB credential (Vault / ESO)
5. Harden SCC + minimal seccomp for API & DB pods

== Translate to Tickets (Samples)
* TM-01: Enforce digest + signature admission in prod
* TM-02: Add baseline deny NetworkPolicy + tier rules
* TM-03: Replace edit/admin Roles with custom Roles
* TM-04: Vault CSI integration for DB secrets
* TM-05: SPO capture & enforce minimal seccomp on API

== Validation Checklist
* Each STRIDE class sampled? (If omitted, justify)
* Top threats have at least one planned control?
* Backlog tickets reference threat IDs?
* Review cadence & owner documented?

== Visuals (Optional)
[mermaid]
----
flowchart LR
	User --> Ingress[Route / Ingress]
	Ingress --> Frontend
	Frontend --> API
	API --> DB[(Database)]
	CI[CI Pipeline] --> Registry[(Image Registry)] --> Nodes
	API --> Logs[(Audit & Logs)]
----

== Solutions/Controls
* GitOps: Declarative, auditable RBAC & policy changes
* RHACS: Supply chain + runtime policy decisions
* Compliance Operator: Drift visibility vs chosen baseline
* SPO: Syscall minimization & SELinux profile lifecycle
* Vault / External Secrets: Reduce secret sprawl & ease rotation

== Summary Table
[options="header"]
|===
| What to Secure | Why It Matters | Example Controls
| Image Integrity | Prevent hidden tampering | Signing, scanning, RHACS gate
| Network Paths | Limit lateral movement | Default deny + tiered policies
| Secrets | Reduce leakage risk | Externalization + scoped RBAC
| Runtime Syscalls | Shrink escape surface | Seccomp/SPO profiles
| Privileged Actions | Stop escalation chains | Custom RBAC + audit
| Compliance State | Avoid silent drift | Tailored profiles + scans
|===

How detailed should the model be?:: Enough to prioritize decisively. If it reads like a thesis, you over‑modeled.
Do we model every microservice?:: Start at tier level; dive deeper only for high‑risk or internet‑facing components.
How often to revisit?:: Triggered by meaningful architecture change, plus at least quarterly.
Is STRIDE mandatory?:: No, use any framework that ensures balanced coverage (PASTA, ATT&CK, etc.).

== Closing Story
The threat model is the cluster’s security blueprint: once drawn, each control placed feels intentional. Without it, defenses accumulate like random furniture—cluttered and still missing a front door lock.

== Next Step Ideas
* Automate a risk score column and generate markdown → ticket sync
* Add Mermaid diagram to your stored model file
* Embed threat IDs into RHACS policy annotations for traceability

