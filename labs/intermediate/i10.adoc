= Lab: Policy at the Front Door – Admission Governance (Gatekeeper)
:role: Intermediate Admission Governance
:skills: Admission Control, Gatekeeper, Policy Layering, Governance
:labid: LAB-I10
:toc:
:sectnums:
:icons: font

== Skill
Admission governance & policy layering. Enforce baseline safety gates before insecure workloads enter the cluster.

== Scenario
Preventing insecure workloads early reduces remediation cost. You will deploy Gatekeeper constraints enforcing: (1) no root UID, (2) mandatory NetworkPolicy presence, (3) signed images (simulated), and (4) digest pinning over floating tags.

== Objectives
* Verify Gatekeeper operator (or install) and constraint CRDs
* Create constraint templates
* Enforce constraints & test violations
* Layer policies with exemptions namespace-scoped

== Prerequisites
* Gatekeeper / OpenShift operator installed (CRDs: ConstraintTemplate, K8sAllowedRepos, etc.)
* Cluster admin privileges

== Namespace Setup
[source,sh]
----
oc new-project i10-govern
----

== No Root UID Constraint
ConstraintTemplate:
[source,sh]
----
oc apply -f - <<'EOF'
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8snonrootuid
spec:
  crd:
    spec:
      names:
        kind: K8sNonRootUid
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8snonrootuid
        violation[{"msg": msg}] {
          input.review.kind.kind == "Pod"
          c := input.review.object.spec.containers[_]
          not c.securityContext.runAsNonRoot
          msg := sprintf("Container %s must set runAsNonRoot=true", [c.name])
        }
EOF
----
Constraint:
[source,sh]
----
oc apply -f - <<'EOF'
apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sNonRootUid
metadata:
  name: nonroot-required
spec: {}
EOF
----

Test (expect denial):
[source,sh]
----
oc apply -n i10-govern -f - <<'EOF'
apiVersion: v1
kind: Pod
metadata:
  name: root-pod
spec:
  containers:
  - name: app
    image: registry.access.redhat.com/ubi9/ubi
    securityContext:
      runAsNonRoot: false
    command: ["sleep","5"]
EOF
----

== Mandatory NetworkPolicy Constraint
Template:
[source,sh]
----
oc apply -f - <<'EOF'
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8snetpolrequired
spec:
  crd:
    spec:
      names:
        kind: K8sNetPolRequired
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8snetpolrequired
        violation[{"msg": msg}] {
          input.review.kind.kind == "Pod"
          ns := input.review.object.metadata.namespace
          not has_network_policy[ns]
          msg := sprintf("Namespace %s lacks a NetworkPolicy", [ns])
        }
        has_network_policy[ns] {
          p := data.inventory.namespace[ns].networkpolicies[_]
        }
EOF
----
Constraint:
[source,sh]
----
oc apply -f - <<'EOF'
apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sNetPolRequired
metadata:
  name: netpol-required
spec: {}
EOF
----
Create a pod (should be denied). Then add a minimal NetworkPolicy and retry:
[source,sh]
----
oc apply -n i10-govern -f - <<'EOF'
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-default
spec:
  podSelector: {}
  policyTypes: [Ingress]
EOF
----
Retry pod with non-root context:
[source,sh]
----
oc apply -n i10-govern -f - <<'EOF'
apiVersion: v1
kind: Pod
metadata:
  name: ok-pod
spec:
  containers:
  - name: app
    image: registry.access.redhat.com/ubi9/ubi@sha256:123fake
    securityContext:
      runAsNonRoot: true
    command: ["sleep","1000"]
EOF
----

== Digest Pinning & (Simulated) Signature Constraint
Simplified example focusing on forbidding mutable tags:
Template:
[source,sh]
----
oc apply -f - <<'EOF'
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8sdigestonly
spec:
  crd:
    spec:
      names:
        kind: K8sDigestOnly
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8sdigestonly
        violation[{"msg": msg}] {
          input.review.kind.kind == "Pod"
          c := input.review.object.spec.containers[_]
          startswith(c.image, "registry.access.redhat.com/")
          not contains(c.image, "@sha256:")
          msg := sprintf("Image %s must use digest", [c.image])
        }
EOF
----
Constraint:
[source,sh]
----
oc apply -f - <<'EOF'
apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sDigestOnly
metadata:
  name: digest-only
spec: {}
EOF
----
Test denial with tag:
[source,sh]
----
oc apply -n i10-govern -f - <<'EOF'
apiVersion: v1
kind: Pod
metadata:
  name: tag-pod
spec:
  containers:
  - name: app
    image: registry.access.redhat.com/ubi9/ubi:latest
    securityContext:
      runAsNonRoot: true
    command: ["sleep","1"]
EOF
----

== Namespace Exemption
[source,sh]
----
oc label namespace i10-govern policy-tier=dev
# Example: refine rego to exempt tier=dev; left as exercise
----

== Cleanup
[source,sh]
----
oc delete project i10-govern --wait=false
----

== Key Points
* Admission prevents drift before runtime
* Layered constraints: identity (non-root), network readiness, supply chain integrity
* Exemptions require explicit labeling → audit trail of risk acceptance
