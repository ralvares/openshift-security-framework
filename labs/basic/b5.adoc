= Lab: Don’t Hardcode – Managing Secrets the Right Way
:labid: LAB-B5
:cis-summary: "Store credentials as Secrets (files or env) instead of hardcoding; support rotation."
:mitre-summary: "Prevents credential exposure by replacing hardcoded values with scoped Secrets and enabling rotation paths."
:audit-evidence: "Hardcoded env var visible in manifest; refactored to Secret env/file; file mount updates after rotation while env requires restart."
:cis-mitre-codes: '{"cisMapping":{"primary":["5.4.1"],"related":[]},"mitre":{"techniques":["T1552"],"tactics":["TA0006"],"mitigations":["M1026"]}}'
:toc:
:sectnums:
:icons: font

== Skill
Remove passwords from manifests, store them as Secrets, inject safely, rotate cleanly.

== Objective

* Insecure hardcoded credential
* Refactor to Secret env var
* Refactor to Secret file mount
* Rotate and compare behaviors

== Why it Matters
Hardcoding credentials is like writing your ATM PIN on the card, anyone who sees it can use it. Storing passwords in Git, manifests, or images spreads them too widely and makes rotation painful. Kubernetes Secrets separate credentials from code, restrict access via RBAC, and support safe rotation (files update in place; env vars on restart), improving security and compliance.

== What it Solves

* Git history leakage
* Rotation friction
* Broad manifest visibility
* Credential reuse temptation

== Understanding the Attack Surface
[cols="1,2,2",options="header"]
|===
|Weak Practice | Risk | Exploitable Outcome
|Plaintext in Git | Persistent disclosure | Former employees retain copies
|Shared Across Apps | Lateral compromise | One breach unlocks many
|No Rotation | Long lifetime | Credential stuffing success
|Env Only Rotation | Missed restart | Stale secret in use
|===

== How to Secure (Lifecycle View)
* Build: Never bake secrets in images.
* Registry: Keep only non-sensitive config baked.
* Deploy: Use Secrets + least privilege RBAC.
* Runtime: Rotate high-value secrets; monitor access.

== How to Try It

=== Project
[source,sh]
----
oc new-project b5-secrets
----

=== Insecure deployment (hardcoded credential)
[source,sh]
----
oc create deployment insecure-app --image=registry.access.redhat.com/ubi9/ubi -- sleep infinity
oc set env deployment/insecure-app DB_PASSWORD=SuperSecret123
oc get deploy insecure-app -o yaml | grep -n 'SuperSecret'
----

=== Remove insecure workload
[source,sh]
----
oc delete deployment insecure-app
----

=== Create a Secret
[source,sh]
----
oc create secret generic db-credentials --from-literal=DB_PASSWORD=SuperSecret123
----

=== Deployment using env var from Secret
[source,sh]
----
oc create deployment secure-app-env --image=registry.access.redhat.com/ubi9/ubi -- sleep infinity
oc set env deployment/secure-app-env --from=secret/db-credentials
oc exec deploy/secure-app-env -- printenv | grep DB_PASSWORD
oc get deploy secure-app-env -o yaml | grep -n 'SuperSecret'
----

=== Deployment mounting Secret as file
[source,sh]
----
oc create deployment secure-app-file --image=registry.access.redhat.com/ubi9/ubi -- sleep infinity
oc set volume deployment/secure-app-file --add --name=creds --type=secret --secret-name=db-credentials --mount-path=/opt/creds --read-only
oc exec deploy/secure-app-file -- ls /opt/creds
oc exec deploy/secure-app-file -- cat /opt/creds/DB_PASSWORD
----

=== Rotate secret (mount auto-updates, env needs restart)
[source,sh]
----
oc create secret generic db-credentials --from-literal=DB_PASSWORD=NewValue456 -o yaml --dry-run=client | oc apply -f -
oc exec deploy/secure-app-file -- cat /opt/creds/DB_PASSWORD
oc rollout restart deployment/secure-app-env
oc exec deploy/secure-app-env -- printenv | grep DB_PASSWORD
----

=== Cleanup (optional)
[source,sh]
----
oc delete project b5-secrets --wait=false
----

== Solutions / Controls

* Kubernetes Secrets abstraction
* Etcd encryption-at-rest
* External KMS integration
* RBAC limiting secret get/list
* RHACS anomaly & secret mount policies

== Summary Table
[cols="1,2,2",options="header"]
|===
|Method | Pros | Cons
|Hardcoded Env | Fast demo | Insecure, unrotatable
|Secret as Env Var | Simple | Restart on rotation
|Secret as File | Seamless rotation | Slightly more app logic
|External KMS | Stronger key custody | Extra setup
|===

== FAQs
Are Secrets encrypted by default?:: Base64 only—enable etcd encryption.
Env var or file better?:: File for rotation agility; env for simplicity.
Commit example secrets?:: Use placeholders only.
Do Secrets stop exfiltration?:: Reduce accidental exposure; still need RBAC & network controls.

== Closing Story
Treat secrets like house keys: stored & rotated intentionally, never glued to the door.

== Next Step Ideas

* Periodic rotation pipeline
* External KMS provider integration
* Repo scanning (gitleaks, truffleHog)