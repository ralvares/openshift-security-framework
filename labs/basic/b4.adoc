= Lab: You Shall Not Pass – Segmenting Pod Traffic with NetworkPolicies
:labid: LAB-B4
:cis-summary: "Apply NetworkPolicies so namespaces default deny and only intended pod traffic is allowed."
:mitre-summary: "Prevents lateral movement and internal scanning via default deny plus narrowly scoped allow rules."
:audit-evidence: "Default connectivity works; default-deny blocks both clients; allow policy restores access only for labeled allowed client (200 vs timeout)."
:cis-mitre-codes: '{"cisMapping":{"primary":["5.3.2"]},"mitre":{"techniques":["T1046"],"tactics":["TA0007"],"mitigations":["M1030","M1042"]}}'
:toc:
:sectnums:
:icons: font

== Skill
Shrink lateral movement by moving from implicit allow-all networking to explicit allow rules via NetworkPolicies.

== Objective

* Observe default pod-to-pod connectivity
* Enforce namespace-level default deny
* Create targeted allow policy for one client
* Validate blocked vs allowed flows

== Why it Matters
Flat networks amplify compromise. NetworkPolicies introduce interior doors—intent over assumption—reducing scan surface and compliance risk.

== What it Solves

* Prevents every compromised pod becoming a pivot
* Reduces accidental exposure of internal services
* Eases incident scoping (“what could it reach?”)
* Supports regulated segmentation requirements

== Understanding the Attack Surface
[cols="1,2,2",options="header"]
|===
|Surface | Risk When Open | Example Abuse
|East-West Traffic | Lateral movement | Probe creds service from frontend
|Lack of Egress Control | Data exfiltration | Leak secrets externally
|Overbroad Labels | Wide unintended allowance | Label matches many pods
|Missing Default Deny | Hidden gaps persist | Sensitive svc reachable
|===

== How to Secure (Lifecycle View)
* Build: Standardize labels (app, role, tier).
* Registry: Harden images to reduce footholds.
* Deploy: Default deny early; allowlists per service.
* Runtime: RHACS network graph to refine policy.

== How to Try It

.Create project & baseline pods
[source,sh]
----
oc new-project b4-netpol-demo
oc create deployment api --image=registry.access.redhat.com/ubi9/python-311 -- python3 -m http.server 8080
oc expose deployment api --port=8080 --target-port=8080
oc run client-allowed --image=registry.access.redhat.com/ubi9/ubi -l role=allowed -- sleep infinity
oc run client-denied  --image=registry.access.redhat.com/ubi9/ubi -l role=denied  -- sleep infinity
SVC=$(oc get svc api -o jsonpath='{.spec.clusterIP}')
----

.Test open connectivity (both succeed)
[source,sh]
----
oc exec client-allowed -- curl -s -o /dev/null -w '%{http_code}\n' http://$SVC:8080
oc exec client-denied  -- curl -s -o /dev/null -w '%{http_code}\n' http://$SVC:8080
----

.Apply default deny (Ingress)
[source,yaml]
----
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-ingress
spec:
  podSelector: {}
  policyTypes:
  - Ingress
----

.Retest (expect timeouts)
[source,sh]
----
oc exec client-allowed -- curl -s --max-time 3 -o /dev/null -w '%{http_code}\n' http://$SVC:8080 || echo TIMEOUT
oc exec client-denied  -- curl -s --max-time 3 -o /dev/null -w '%{http_code}\n' http://$SVC:8080 || echo TIMEOUT
----

.Allow only approved client
[source,yaml]
----
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-api-from-allowed
spec:
  podSelector:
    matchLabels:
      app: api
  ingress:
  - from:
    - podSelector:
        matchLabels:
          role: allowed
    ports:
    - protocol: TCP
      port: 8080
  policyTypes:
  - Ingress
----

.Retest (allowed=200, denied timeout)
[source,sh]
----
oc exec client-allowed -- curl -s -o /dev/null -w '%{http_code}\n' http://$SVC:8080
oc exec client-denied  -- curl -s --max-time 3 -o /dev/null -w '%{http_code}\n' http://$SVC:8080 || echo BLOCKED
----

.Cleanup (optional)
[source,sh]
----
oc delete project b4-netpol-demo --wait=false
----

== Solutions / Controls

* NetworkPolicies for microsegmentation
* Standard labels as controlled vocabulary
* RHACS network graph for visualization
* Zero trust mindset: default deny + explicit allow

== Visual (ASCII – Ingress Allow vs Deny)
[source,text]
----
PHASE 1 (No Policies)
client-allowed  ---> api (200)
client-denied   ---> api (200)

PHASE 2 (Default Deny Ingress)
client-allowed  -X-> api (timeout)
client-denied   -X-> api (timeout)

PHASE 3 (Allow Specific Client)
client-allowed  ---> api (200)
client-denied   -X-> api (timeout)

Legend: ---> allowed HTTP 200   -X-> blocked/timeout
----

== Summary Table
[cols="1,2,2",options="header"]
|===
|What to Secure | Risk | Control
|East-West Traffic | Lateral expansion | Default deny + allowlist
|Labeling Consistency | Policy gaps | Enforced taxonomy
|High-Sensitivity Services | Data exposure | Targeted ingress policies
|Drift Over Time | Stale rules | Periodic review + RHACS
|===

== FAQs
Do NetworkPolicies block egress by default?:: Only if egress types specified.
Why start with default deny?:: Reveals necessary connections.
Are they node firewalls?:: Enforced at pod interfaces via CNI.
How to avoid label sprawl mistakes?:: Minimal taxonomy: app, role, tier, env.

== Closing Story
Segmentation converts a wide-open warehouse into purposeful rooms; movement remains—but intentional.

== Next Step Ideas

* Add egress example (allow DNS, block external)
* Bundle policies into a single manifest
* Visualize flows pre/post with RHACS


