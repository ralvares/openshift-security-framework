= Lab: Why This Third-Party App Fails (SCC & Non-Root Realities)
:labid: LAB-B3A
:cis-summary: "Restrict granting of privileged SCCs like anyuid—prefer fixing images to run under restricted defaults."
:mitre-summary: "Prevents container privilege escalation by denying root/privileged assumptions and discouraging anyuid exceptions."
:audit-evidence: "Port 80 start and runAsUser=0 fail under restricted; after anyuid grant pod runs as UID 0 illustrating risky exception."
:cis-mitre-codes: '{"cisMapping":{"primary":["5.2.6"]},"mitre":{"techniques":["T1611"],"tactics":["TA0004"],"mitigations":["M1048","M1026"]}}'
:toc:
:sectnums:
:icons: font

== Skill
Learn that third-party applications (like vendor or legacy software) often can't be rebuilt or modified to fit OpenShift's security requirements, such as running without root privileges or binding to privileged ports. In these real-world scenarios, the key skill is to analyze the specific security risks and make an informed decision to accept those risks, rather than automatically weakening platform security by granting broad permissions like anyuid. You'll diagnose why such an image fails on OpenShift, understand the security implications, and learn responsible risk management with proper documentation.

== Objective

* Attempt to run a container binding privileged port 80 and observe failure
* Attempt to force root (runAsUser=0) and see SCC block it
* Grant anyuid and observe the container now runs as root on port 80
* Explain why this is insecure and when the proper alternative is to analyze and accept the risk (for third-party apps where rebuilding is not feasible)

== Why it Matters
Using an image that insists on a fixed user or root is like a touring band demanding to rewire your venue’s electrical system before playing. You could say yes (faster “win”), but you inherit fire risk, insurance issues, and future lock-in. Granting anyuid is the platform equivalent: a convenience that normalizes bypassing guardrails.

OpenShift injects a random non-root UID so containers can’t rely on root. Images built without flexible ownership (root:0 with group write) break, flushing out insecure design early. The business upside: fewer “surprise” escalations, simpler compliance (“all workloads non-root by default”), and faster production readiness.

NOTE: Permission Requirements for This Lab
Most steps require only project-level access. Granting the `anyuid` SCC needs cluster-admin (or delegated). Forbidden errors are expected guardrails.

== What it Solves
* Eliminates silent privilege creep (running as root “just because”)
* Discourages shipping rigid vendor images with hard-coded UIDs
* Prevents broad SCC sprawl (exception fatigue)
* Forces reusable, multi-tenant safe image patterns

Attackers look for root-running containers or SCC exceptions. By refusing them upfront, you reduce accessible pathways before an exploit even runs.

== Understanding the Attack Surface
[cols="1,2,2",options="header"]
|===
|Area | Risk If Ignored | Analogy
|Privileged Port (80) Requirement | Forces elevation; encourages anyuid grant | Band demands rewiring venue power
|Hard-Coded Root Expectation | Normalizes high-privilege baseline | Always giving guests master keys
|Fixed UID Ownership in Image | Leads to permission hacks / SCC exceptions | Furniture bolted for one resident
|Granting anyuid Broadly | Expands blast radius for compromise | Removing door locks for convenience
|Missing Writable Group Ownership | Ops weaken guardrails to “make it work” | Disabling smoke alarm to stop beeping
|Running as Root + Writable FS | Host / kernel probing path | Car left idling with doors unlocked
|Lack of Audit on SCC Exceptions | Drift accumulates | Untracked temporary badges pile up
|No Education on High Ports | Repeated privileged port asks | Insisting on vault door, not side entrance
|===

== How to Secure (Lifecycle View)
* Build: Ensure writable dirs are group-writable; avoid USER root in final stage.
* Registry: Store only images passing a non-root readiness check.
* Deploy: For third-party apps, analyze risks and register acceptance with annotations; rely on restricted SCC otherwise.
* Runtime: RHACS policy flags root or privileged UID usage.

== How to Try It

=== Project
[source,sh]
----
oc new-project b3-scc-demo
----

=== Deploy (attempting privileged port 80)
[source,sh]
----
oc create deployment vendor-app --image=registry.access.redhat.com/ubi9/python-311 -- python3 -m http.server 80
oc logs -l app=vendor-app --tail=50
----
Expected: CrashLoopBackOff with PermissionError (binding port 80).

=== Attempt to force root (runAsUser=0) – expect denial
[source,sh]
----
oc patch deployment vendor-app --type='json' -p='[{"op":"add","path":"/spec/template/spec/securityContext","value":{"runAsUser":0}}]'
oc rollout restart deployment/vendor-app
oc get events --sort-by=.lastTimestamp | grep vendor-app | tail -n 5 || true
----
Look for invalid UID range / runAsUser errors.

=== Grant anyuid (anti-pattern, requires cluster-admin)
[source,sh]
----
oc adm policy add-scc-to-user anyuid -z default || echo 'Expected Forbidden if not admin'
oc rollout restart deployment/vendor-app
oc exec deploy/vendor-app -- id -u || true
oc logs -l app=vendor-app --tail=10 || true
----
If succeeded (not recommended): id -u = 0 and server listens on 80.

=== Register Risk Acceptance (namespace annotation)
For third‑party apps where rebuilding is not possible, analyze the risk and formally register the acceptance so it’s discoverable and auditable.

Multiple deployments? Use one of these patterns:
* Preferred: annotate each Deployment with its own risk-acceptance metadata
* Optional index: annotate the namespace with per-deployment keys to avoid overlap (suffix the key with the deployment name)

[source,sh]
----
oc annotate namespace b3-scc-demo \
	openshift.io/risk-accepted.vendor-app="Requires anyuid for privileged port" \
	openshift.io/risk-accepted-approved-by.vendor-app="InfoSec Team" \
	--overwrite
----

=== Verify annotation
[source,sh]
----
oc get ns b3-scc-demo -o yaml | grep -E 'openshift.io/risk-accepted'
----

NOTE: Keep this for exceptional cases. The preferred path is to rebuild images so they run under the restricted SCC without anyuid.

=== Cleanup (optional)
[source,sh]
----
oc delete project b3-scc-demo --wait=false
----

== Solutions / Controls

* Restricted SCC dominance
* Controlled anyuid exceptions with review
* Image hardening pipelines (fail on USER root)
* RHACS detection of root / capability drift

== Summary Table
[cols="1,2,2",options="header"]
|===
|Issue | Bad Shortcut | Secure Fix
|Privileged port 80 fails | Grant anyuid | Use high port (8080)
|Writable dirs missing | chmod at runtime | Fix ownership during build
|Legacy root-only startup | Persist anyuid exception | Analyze risk and accept with annotations
|===

== Error Interpretation Cheat Sheet
[cols="1,2,1,2,2",options="header"]
|===
|Phase | Symptom | Source | Meaning | Right Response
|Port 80 start | PermissionError 13 | App log | Non-root blocked on privileged port | Change to high port
|runAsUser=0 patch | SecurityContext warnings | PodSecurity | Harden settings not declared | Informational
|runAsUser=0 patch | FailedCreate UID invalid | SCC | UID 0 outside allowed range | Drop root attempt
|After anyuid | id -u = 0 on 80 | anyuid SCC | Guardrail bypassed | Revert and refactor
|===

== FAQs
Why random UID instead of a fixed one?:: Prevents brittle assumptions; enforces portability.
Is anyuid always bad?:: Not inherently—broad usage is.
Can SELinux cause similar failures?:: Yes; rule out UID/perm design first, then inspect AVC denials.

== Closing Story
Granting anyuid because an image fails is like removing a seatbelt because it’s “too tight.” Fix the workload; keep the safety system.

== Next Step Ideas

* Add CI linting: warn on USER root
* Inventory existing anyuid bindings

== Comparison (Before vs After Behavior)
[cols="2,1,1,1,2",options="header"]
|===
|Image + Command | Runs As (SCC) | Port | Result | Why
|ubi9/python-311 + http.server 80 | random non-root (restricted) | 80 | Fails | Privileged port
|ubi9/python-311 + http.server 8080 | random non-root (restricted) | 8080 | Succeeds | High port
|(Anti-pattern) same + anyuid | root (anyuid) | 80 | Succeeds | Guardrail removed
|===
