
= Securing ExternalName Services with AdminNetworkPolicy, BANP, and Developer NetworkPolicies

This guide explains how to securely expose external APIs to applications using Kubernetes `ExternalName` Services, enforced by a layered network security model:

- **AdminNetworkPolicy (ANP)** and **BaselineAdminNetworkPolicy (BANP)** enforce the cluster perimeter: default deny, DNS, monitoring, and (if allowed) egress to specific external networks.
- **Developer NetworkPolicies** control pod-to-pod and in-namespace egress, but cannot override the perimeter set by ANP/BANP.

This pattern ensures:

- Developers only call *internal* service names.
- Platform/security teams control which namespaces can reach external endpoints (via ANP labels and policy).
- All egress is deterministic, auditable, and tightly controlled.


== When to use an ExternalName Service

Use an `ExternalName` Service when:

- Applications must call an external SaaS/API (e.g., `api.vulnerawise.ai`).
- You want to avoid developers hardcoding external hostnames or IPs.
- You want a stable, internal DNS name that the platform team can repoint as needed.
- You want to combine this with strict egress controls enforced by ANP/BANP and developer NetworkPolicies.

With this pattern, developers treat the external API as an internal Service. Platform/security teams control the real external endpoints and which namespaces can reach them, enforced by AdminNetworkPolicy.



== High-level Architecture: ANP-based Egress Control

1. **AdminNetworkPolicy (ANP)** and **BANP** enforce a default deny perimeter for all owned namespaces. Only namespaces with the label `security.allow/networks: "true"` can egress to approved external networks.
2. Applications call an internal DNS name: `https://vulnerawise-api.externalname.svc`.
3. Kubernetes DNS maps that name to the external hostname: `api.vulnerawise.ai` via an `ExternalName` Service.
4. The ANP allows egress to the specific IP range for `api.vulnerawise.ai` (as determined by platform/security). No developer NetworkPolicy is required for egress; the ANP enforces the perimeter.

Result: Developers use clean, internal endpoints. Security teams control which namespaces can egress, and to which destinations, enforced by ANP/BANP. Developer NetworkPolicies are not required for egress in this pattern.


== Step 1: Create the ExternalName Service

Applications should *not* hardcode external hostnames or IPs. Instead, define a stable, internal Service that points to the external host:

[source,bash]
----
cat <<EOF | oc apply -f -
apiVersion: v1
kind: Service
metadata:
  name: vulnerawise-api
  namespace: externalname
spec:
  type: ExternalName
  externalName: api.vulnerawise.ai
EOF
----

Developers now call:

[source]
----
https://vulnerawise-api.externalname.svc
----

Kubernetes DNS transparently maps that internal name to `api.vulnerawise.ai`. If the SaaS provider changes IP or hostname, platform teams update the Service or DNS, not application code.


== Step 2: Deploy a Test Pod

To verify the flow and policies end-to-end, create a simple test pod. In real environments, this is your application workload.

[source,bash]
----
oc -n externalname run curltester \
  --image=quay.io/curl/curl \
  --restart=Never \
  --command -- sleep infinity
----

The pod gets the label:

[source]
----
run=curltester
----

We will use this label in all egress NetworkPolicies.



// Step 3 removed: Default deny egress is enforced by ANP/BANP, not by developer NetworkPolicy. No additional deny-all egress policy is required at the namespace level.



// Step 4 removed: DNS egress is always allowed for owned namespaces by ANP. No developer NetworkPolicy is required for DNS.



== Step 3: Allow Egress to the API IP Range (ANP)

Platform/security determines the current IP range for the external API (e.g., `api.vulnerawise.ai`).

[source]
----
api.vulnerawise.ai -> 51.79.73.188/32
----

The ANP is configured to allow egress to this IP range for namespaces with the label `security.allow/networks: "true"`:

[source,yaml]
----
apiVersion: policy.networking.k8s.io/v1alpha1
kind: AdminNetworkPolicy
metadata:
  name: corporate-external-networks-guardrail
spec:
  priority: 12
  subject:
    namespaces:
      matchLabels:
        security.allow/networks: "true"
  egress:
    - name: allow-vulnerawise-api
      action: Allow
      to:
        - networks:
            - 51.79.73.188/32
      ports:
        - portNumber:
            protocol: TCP
            port: 443
----

No developer NetworkPolicy is required for egress. The ANP enforces the perimeter and allows only the approved external API IP/port.



== Step 4: Test the Secured ExternalName Path

Verify each step from the applicationâ€™s perspective. If the namespace does not have `security.allow/networks: "true"`, all external calls will be blocked by ANP regardless of developer NetworkPolicy.

DNS resolution using the internal name:

[source,bash]
----
oc -n externalname exec curltester -- nslookup vulnerawise-api
----

Call the ExternalName URL (what developers would use):

[source,bash]
----
oc -n externalname exec curltester -- curl -vk \
  https://vulnerawise-api.externalname.svc/v1/vuln?cve=CVE-2025-2368
----

Call the direct IP (to confirm the NetworkPolicy behavior):

[source,bash]
----
oc -n externalname exec curltester -- curl -vk \
  https://51.79.73.188/v1/vuln?cve=CVE-2025-2368
----

Try a blocked destination (should fail):

[source,bash]
----
oc -n externalname exec curltester -- curl -vk https://google.com
----



== Enforcement Boundaries: Developers vs. Security

From the *developer* point of view:

- They call `https://vulnerawise-api.externalname.svc` like any other internal Service.
- They never need to track the external hostname, IP, or TLS endpoint.
- Changing providers or endpoints only requires a platform-level change.

From the *platform/security* point of view:

- Egress is default-deny at the namespace boundary, enforced by ANP/BANP.
- Only namespaces with the label `security.allow/networks: "true"` can egress to approved external networks.
- DNS egress is always allowed for owned namespaces.
- No developer NetworkPolicy is required for egress in this pattern; ANP enforces the perimeter.
- The ExternalName Service gives a clean abstraction boundary between application code and external infrastructure.



== Summary: ANP/BANP for ExternalName Egress

Using an `ExternalName` Service plus strict AdminNetworkPolicy and BANP gives you:

- Default-deny egress at the cluster perimeter (ANP/BANP)
- Minimal, well-defined DNS access (always allowed for owned namespaces)
- Egress to external APIs only for namespaces explicitly allowed by ANP (`security.allow/networks: "true"`)
- Clean, internal service names for developers
- No reliance on EgressFirewall or developer egress NetworkPolicies
- A repeatable, auditable pattern for controlled egress in OpenShift using pure Kubernetes admin policies

This lets developers focus on stable internal APIs, while security and platform teams safely manage and lock down actual external connectivity at the perimeter using ANP.