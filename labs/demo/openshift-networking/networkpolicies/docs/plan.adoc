= Cluster Network Security Operationalization Plan

This document defines a phased approach for implementing a consistent, least-privilege network-security model on OpenShift, fully aligned with the actual AdminNetworkPolicies (ANPs), BaselineAdminNetworkPolicy (BANP), and onboarding workflow. It reflects the real enforcement model: monitoring ingress is always allowed by policy, only kube-API and corporate egress are label-gated, and all other flows are denied by default.


== 1. Objectives

- Enforce a consistent, least-privilege security posture for all business application namespaces
- Deny-by-default for all ingress and egress except where explicitly allowed
- Use a minimal, stable suite of AdminNetworkPolicies to define the cluster perimeter
- Allow developers to define safe, reviewable traffic patterns inside their namespaces
- Maintain visibility and auditability for all allowed and denied flows


== 2. Guiding Principles

[cols="1,3",options="header"]
|===
| Principle | Description
| Deny by default | All ingress and egress is denied unless explicitly allowed by policy.
| Immutable guardrails | The AdminNetworkPolicy suite is minimal and rarely changes, defining the cluster perimeter.
| Namespace autonomy | Application teams manage `NetworkPolicy` objects inside their namespaces for pod-to-pod traffic.
| GitOps-first | All policy changes (Admin or namespace level) are managed via version control and approval workflows.
| Auditability | Every approval, exception, and change is traceable to a ticket and a commit.
|===


== 3. Network Security Layers

This layered model matches the real enforcement and onboarding workflow:

[cols="1,2,1,3",options="header"]
|===
| Tier | Object Type | Owner | Purpose
| 1 | `AdminNetworkPolicy` suite (ANPs) | Security / Platform | Enforce global perimeter: monitoring ingress, DNS egress, kube-API egress (label-gated), corporate egress (label-gated), and final default-deny.
| 2 | Namespace `NetworkPolicy` | Application teams | Define application-level service boundaries, ingress and egress within the allowed perimeter.
| 3 | `BaselineAdminNetworkPolicy` (BANP) | Security | Provide cluster-wide default deny between owned namespaces unless allowed by ANP.
|===

Direct egress to the Internet is not allowed; only egress to corporate networks is possible for namespaces with the correct label.

business.workload/owned=true

== 4. Phase 1 - Foundation

Goal: establish a predictable, enforced perimeter for all owned namespaces.

.Deploy and standardize the AdminNetworkPolicy suite
- Apply the ANP suite to all namespaces with `business.workload/owned=true`.
- The suite includes:
  - Monitoring ingress always allowed from `openshift-monitoring` and `openshift-user-workload-monitoring`
  - DNS egress always allowed to `openshift-dns`
  - Kube-API egress allowed only for namespaces with `security.allow/kapi: "true"`
  - Corporate egress allowed only for namespaces with `security.allow/networks: "true"`
  - All other ingress/egress denied by default
- BANP enforces default deny between owned namespaces unless allowed by ANP.
- Treat these ANPs as a stable contract; changes require Security approval and review.

.Namespace labels for gating
- Every application namespace must have:

[source,yaml]
----
business.workload/owned=true
----

- Only kube-API and corporate egress require additional labels:
  - `security.allow/kapi: "true"` (for kube-API egress)
  - `security.allow/networks: "true"` (for corporate egress)

.Align onboarding with the perimeter
- The onboarding workflow provisions namespaces with `business.workload/owned=true` from day one.
- No label or request is needed for monitoring: it is always allowed by policy for all owned namespaces.


== 5. Phase 2 - Application NetworkPolicies

Goal: give application teams clear patterns for defining traffic inside the perimeter.

.Provide NetworkPolicy templates
- Offer reusable examples, such as:
  - "default deny" for ingress and egress
  - "frontend → backend" only
  - "app → database" over a specific port
- Store these templates with application configuration for reuse.

.Document recommended patterns
- Teams should:
  - Start from a deny-all posture
  - Add explicit allow rules only for required flows
  - Use namespace selectors and pod labels consistently
- NetworkPolicies cannot override AdminNetworkPolicy or BANP decisions.

.Integrate with GitOps
- All NetworkPolicy objects must be managed in version control
- Use CI checks (linting, schema validation) to catch mistakes before merge


== 6. Phase 3 - Monitoring and Feedback

Goal: validate that the perimeter and policies behave as intended and support troubleshooting.


.Enable flow visibility
- Use NetObserv (or equivalent) to observe:
  - Allowed flows between namespaces and pods
  - Dropped connections due to AdminNetworkPolicy, BANP, or NetworkPolicy decisions

  If you are using a standard cluster, cycle to the packet drops view. In this output, you may see that the traffic is dropped by OVS:

  [source]
  ----
  Dropped Bytes   Dropped Packets   Drop State      Drop Cause         Drop Flags
  74B             1                 TCP_SYN_SENT    OVS_DROP_EXPLICIT  2
  74B             1                 TCP_SYN_SENT    OVS_DROP_EXPLICIT  2
  ----

  You will need to investigate to get to the root cause. Most often, this is due to a configuration issue, such as a missing or misconfigured network policy.

  If you are using the TechPreview feature, cycle to the network events view. In the following output, you may see that the traffic is blocked by a network policy:

  [source]
  ----
  Network Events
  Dropped by network policies isolation in namespace connectivity-scenario, direction Ingress
  ----

  These views help you quickly determine whether a drop is due to OVS (infrastructure-level) or a specific network policy, and guide your troubleshooting process.

.Operational feedback loop
- When drops impact applications, teams:
  - Inspect flows to identify the blocked path
  - Propose NetworkPolicy updates inside their namespace
  - If the drop is at the AdminNetworkPolicy tier, raise a Security request with justification

.Periodic reviews
- Security and Platform regularly:
  - Review AdminNetworkPolicy and BANP for unnecessary complexity
  - Validate that label usage (`business.workload/owned`, `security.allow/kapi`, `security.allow/networks`) matches current requirements


== 7. Example Policy Stack for a Namespace

For a business namespace such as `payments-prod`:

- `AdminNetworkPolicy` suite (cluster):
  - `deny-all-allow-dns-monitoring-owned-namespaces.yaml`: allows DNS egress, monitoring ingress, and passes traffic between owned namespaces; denies all else
  - `kubeapi-egress-guardrail.yaml`: allows kube-API egress only for namespaces with `security.allow/kapi: "true"`
  - `corporate-external-networks-guardrail.yaml`: allows egress to corporate networks only for namespaces with `security.allow/networks: "true"`
- `BaselineAdminNetworkPolicy` (BANP): enforces default deny between owned namespaces unless allowed by ANP
- Namespace `NetworkPolicy`: controls frontend → backend, app → database, and in-namespace ingress/egress

This stack matches the real enforcement and onboarding documentation and applies consistently across environments.


== 8. Governance Lifecycle (Networking Focus)

[cols="2,2,3",options="header"]
|===
| Event | Trigger | Action
| New application namespace | Project request and onboarding | Platform creates the namespace with `business.workload/owned=true` and brings it under AdminNetworkPolicy
| Need for kube-API or corporate egress | Developer request | Security reviews and, if approved, sets the appropriate label (`security.allow/kapi` or `security.allow/networks`)
| Change to application traffic | Developer PR | Team updates namespace `NetworkPolicy` via GitOps; CI validates, and changes are rolled out
| Unexpected drops or connectivity issues | Application incident | Teams inspect flows, adjust `NetworkPolicy` if needed, or request a perimeter change from Security
|===



== 9. Admission Controls: Blocking Allow-All NetworkPolicies

To prevent developers from bypassing security baselines, a ValidatingAdmissionPolicy (VAP) is enforced to block "allow-all" NetworkPolicies in developer-owned namespaces. This ensures that only restrictive or workload-scoped policies are permitted, while any policy that would open the entire namespace is denied.

**Allowed:**

* Deny-all policies (ingress: [], egress: [])
* Normal workload-scoped NetworkPolicies
* Any restrictive rules

**Blocked:**

* Any NetworkPolicy that combines:
  * podSelector: {}
  * ingress: [{}] or egress: [{}]
These patterns reopen the entire namespace and must be prohibited.

The binding ensures the rule applies only to namespaces labeled:

    business.workload/owned=true

This closes the security gap without breaking developer autonomy.

=== ValidatingAdmissionPolicy (VAP)

Blocks allow-all but permits deny-all.

```yaml
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingAdmissionPolicy
metadata:
  name: block-allow-all-netpol
spec:
  failurePolicy: Fail
  matchConstraints:
    resourceRules:
      - apiGroups: ["networking.k8s.io"]
        apiVersions: ["v1"]
        operations: ["CREATE", "UPDATE", "PATCH"]
        resources: ["networkpolicies"]
  validations:
    - expression: "!(
        object.spec.podSelector == {} &&
        (
          (has(object.spec.ingress) && size(object.spec.ingress) == 1 && object.spec.ingress[0] == {}) ||\n+          (has(object.spec.egress)  && size(object.spec.egress)  == 1 && object.spec.egress[0]  == {})
        )
      )"
      message: "Allow-all NetworkPolicies (empty {} ingress/egress rules) are forbidden. Deny-all is allowed."
```

=== ValidatingAdmissionPolicyBinding

Applies only to developer-owned namespaces.

```yaml
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingAdmissionPolicyBinding
metadata:
  name: block-allow-all-netpol-owned-ns
spec:
  policyName: block-allow-all-netpol
  validationActions:
    - Deny
  matchResources:
    namespaceSelector:
      matchLabels:
        business.workload/owned: "true"
```

== 10. Summary

This plan operationalizes the real network-security model by:

- Using a stable, minimal AdminNetworkPolicy suite as the perimeter
- Gating only kube-API and corporate egress via namespace labels
- Always allowing monitoring ingress by policy for all owned namespaces
- Letting application teams define internal traffic with NetworkPolicies under GitOps control
- Enforcing admission controls with ValidatingAdmissionPolicy (VAP) to block allow-all NetworkPolicies and prevent bypass of security baselines
- Providing monitoring and feedback loops to keep the posture least-privilege and practical over time

The result is a predictable, auditable, and developer-friendly network-security posture for OpenShift application namespaces.