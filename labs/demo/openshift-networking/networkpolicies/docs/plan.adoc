
= Cluster Network Security Operationalization Plan

This document defines a phased approach for implementing a consistent, least-privilege network-security model on OpenShift, fully aligned with the actual AdminNetworkPolicies (ANPs), BaselineAdminNetworkPolicy (BANP), and onboarding workflow. It reflects the real enforcement model: monitoring ingress is always allowed by policy, only kube-API and corporate egress are label-gated, and all other flows are denied by default.


== 1. Objectives

- Enforce a consistent, least-privilege security posture for all business application namespaces
- Deny-by-default for all ingress and egress except where explicitly allowed
- Use a minimal, stable suite of AdminNetworkPolicies to define the cluster perimeter
- Allow developers to define safe, reviewable traffic patterns inside their namespaces
- Maintain visibility and auditability for all allowed and denied flows


== 2. Guiding Principles

[cols="1,3",options="header"]
|===
| Principle | Description
| Deny by default | All ingress and egress is denied unless explicitly allowed by policy.
| Immutable guardrails | The AdminNetworkPolicy suite is minimal and rarely changes, defining the cluster perimeter.
| Namespace autonomy | Application teams manage `NetworkPolicy` objects inside their namespaces for pod-to-pod traffic.
| GitOps-first | All policy changes (Admin or namespace level) are managed via version control and approval workflows.
| Auditability | Every approval, exception, and change is traceable to a ticket and a commit.
|===


== 3. Network Security Layers

This layered model matches the real enforcement and onboarding workflow:

[cols="1,2,1,3",options="header"]
|===
| Tier | Object Type | Owner | Purpose
| 1 | `AdminNetworkPolicy` suite (ANPs) | Security / Platform | Enforce global perimeter: monitoring ingress, DNS egress, kube-API egress (label-gated), corporate egress (label-gated), and final default-deny.
| 2 | Namespace `NetworkPolicy` | Application teams | Define application-level service boundaries, ingress and egress within the allowed perimeter.
| 3 | `BaselineAdminNetworkPolicy` (BANP) | Security | Provide cluster-wide default deny between owned namespaces unless allowed by ANP.
|===

Direct egress to the Internet is not allowed; only egress to corporate networks is possible for namespaces with the correct label.

business.workload/owned=true

== 4. Phase 1 - Foundation

Goal: establish a predictable, enforced perimeter for all owned namespaces.

.Deploy and standardize the AdminNetworkPolicy suite
- Apply the ANP suite to all namespaces with `business.workload/owned=true`.
- The suite includes:
  - Monitoring ingress always allowed from `openshift-monitoring` and `openshift-user-workload-monitoring`
  - DNS egress always allowed to `openshift-dns`
  - Kube-API egress allowed only for namespaces with `security.allow/kapi: "true"`
  - Corporate egress allowed only for namespaces with `security.allow/networks: "true"`
  - All other ingress/egress denied by default
- BANP enforces default deny between owned namespaces unless allowed by ANP.
- Treat these ANPs as a stable contract; changes require Security approval and review.

.Namespace labels for gating
- Every application namespace must have:

[source,yaml]
----
business.workload/owned=true
----

- Only kube-API and corporate egress require additional labels:
  - `security.allow/kapi: "true"` (for kube-API egress)
  - `security.allow/networks: "true"` (for corporate egress)

.Align onboarding with the perimeter
- The onboarding workflow provisions namespaces with `business.workload/owned=true` from day one.
- No label or request is needed for monitoring: it is always allowed by policy for all owned namespaces.


== 5. Phase 2 - Application NetworkPolicies

Goal: give application teams clear patterns for defining traffic inside the perimeter.

.Provide NetworkPolicy templates
- Offer reusable examples, such as:
  - "default deny" for ingress and egress
  - "frontend → backend" only
  - "app → database" over a specific port
- Store these templates with application configuration for reuse.

.Document recommended patterns
- Teams should:
  - Start from a deny-all posture
  - Add explicit allow rules only for required flows
  - Use namespace selectors and pod labels consistently
- NetworkPolicies cannot override AdminNetworkPolicy or BANP decisions.

.Integrate with GitOps
- All NetworkPolicy objects must be managed in version control
- Use CI checks (linting, schema validation) to catch mistakes before merge


== 6. Phase 3 - Monitoring and Feedback

Goal: validate that the perimeter and policies behave as intended and support troubleshooting.

.Enable flow visibility
- Use NetObserv (or equivalent) to observe:
  - Allowed flows between namespaces and pods
  - Dropped connections due to AdminNetworkPolicy, BANP, or NetworkPolicy decisions

.Operational feedback loop
- When drops impact applications, teams:
  - Inspect flows to identify the blocked path
  - Propose NetworkPolicy updates inside their namespace
  - If the drop is at the AdminNetworkPolicy tier, raise a Security request with justification

.Periodic reviews
- Security and Platform regularly:
  - Review AdminNetworkPolicy and BANP for unnecessary complexity
  - Validate that label usage (`business.workload/owned`, `security.allow/kapi`, `security.allow/networks`) matches current requirements


== 7. Example Policy Stack for a Namespace

For a business namespace such as `payments-prod`:

- `AdminNetworkPolicy` suite (cluster):
  - `deny-all-allow-dns-monitoring-owned-namespaces.yaml`: allows DNS egress, monitoring ingress, and passes traffic between owned namespaces; denies all else
  - `kubeapi-egress-guardrail.yaml`: allows kube-API egress only for namespaces with `security.allow/kapi: "true"`
  - `corporate-external-networks-guardrail.yaml`: allows egress to corporate networks only for namespaces with `security.allow/networks: "true"`
- `BaselineAdminNetworkPolicy` (BANP): enforces default deny between owned namespaces unless allowed by ANP
- Namespace `NetworkPolicy`: controls frontend → backend, app → database, and in-namespace ingress/egress

This stack matches the real enforcement and onboarding documentation and applies consistently across environments.


== 8. Governance Lifecycle (Networking Focus)

[cols="2,2,3",options="header"]
|===
| Event | Trigger | Action
| New application namespace | Project request and onboarding | Platform creates the namespace with `business.workload/owned=true` and brings it under AdminNetworkPolicy
| Need for kube-API or corporate egress | Developer request | Security reviews and, if approved, sets the appropriate label (`security.allow/kapi` or `security.allow/networks`)
| Change to application traffic | Developer PR | Team updates namespace `NetworkPolicy` via GitOps; CI validates, and changes are rolled out
| Unexpected drops or connectivity issues | Application incident | Teams inspect flows, adjust `NetworkPolicy` if needed, or request a perimeter change from Security
|===


== 9. Summary

This plan operationalizes the real network-security model by:

- Using a stable, minimal AdminNetworkPolicy suite as the perimeter
- Gating only kube-API and corporate egress via namespace labels
- Always allowing monitoring ingress by policy for all owned namespaces
- Letting application teams define internal traffic with NetworkPolicies under GitOps control
- Providing monitoring and feedback loops to keep the posture least-privilege and practical over time

The result is a predictable, auditable, and developer-friendly network-security posture for OpenShift application namespaces.
